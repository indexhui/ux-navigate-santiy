"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _FormBuilderInput = require("@sanity/form-builder/lib/FormBuilderInput");

var _PatchEvent = _interopRequireWildcard(require("@sanity/form-builder/PatchEvent"));

var _components = require("@sanity/base/components");

var _client = _interopRequireDefault(require("part:@sanity/base/client"));

var _ui = require("@sanity/ui");

var _autoId = require("@reach/auto-id");

var _changeIndicators = require("@sanity/base/change-indicators");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var metaFieldNames = ['meta', 'openGraph'];

var count = obj => Object.keys(obj || {}).length;

var sanityClient = _client.default.withConfig({
  apiVersion: 'v1'
});

var UrlMetadataInput = /*#__PURE__*/_react.default.forwardRef((props, forwardedRef) => {
  var _type$options;

  var value = props.value,
      compareValue = props.compareValue,
      type = props.type,
      level = props.level,
      onFocus = props.onFocus,
      onBlur = props.onBlur,
      onChange = props.onChange,
      focusPath = props.focusPath,
      readOnly = props.readOnly,
      markers = props.markers,
      presence = props.presence;
  var resolvedUrl = value && value.resolvedUrl;

  var _useState = (0, _react.useState)(false),
      _useState2 = _slicedToArray(_useState, 2),
      hasEdited = _useState2[0],
      setHasEdited = _useState2[1];

  var _useState3 = (0, _react.useState)(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isLoading = _useState4[0],
      setIsLoading = _useState4[1];

  var requestRef = (0, _react.useRef)();
  var inputId = (0, _autoId.useId)();
  var toast = (0, _ui.useToast)();
  var collapsed = type === null || type === void 0 ? void 0 : (_type$options = type.options) === null || _type$options === void 0 ? void 0 : _type$options.collapsed;
  var handleUrlChange = (0, _react.useCallback)(newValue => {
    setHasEdited((value === null || value === void 0 ? void 0 : value.url) !== newValue.trim());

    if (!newValue) {
      onChange(_PatchEvent.default.from((0, _PatchEvent.unset)()));
      return;
    }

    onChange(_PatchEvent.default.from((0, _PatchEvent.unset)(), (0, _PatchEvent.set)({
      _type: type.name,
      url: newValue.trim()
    })));
  }, [onChange, setHasEdited, value]);
  var handleBeforeUrlChange = (0, _react.useCallback)(event => {
    handleUrlChange(event.target.value);
  }, [handleUrlChange]);
  var handleFocus = (0, _react.useCallback)(() => {
    setHasEdited(false);
    onFocus(['url']);
  }, [setHasEdited, onFocus]); // @todo Provide fetch error as validation error?

  var handleFetchError = (0, _react.useCallback)(err => {
    // eslint-disable-next-line
    console.log('Error fetching metadata: ', err);
    toast.push({
      status: 'error',
      title: 'Failed to fetch URL metadata',
      description: err.message
    });
    setIsLoading(false);
  }, [toast, setIsLoading]);
  var handleReceiveMetadata = (0, _react.useCallback)((body, url) => {
    setIsLoading(false);
    setHasEdited(false);
    var statusCode = body.statusCode,
        newResolvedUrl = body.resolvedUrl,
        error = body.error;

    if (!statusCode || statusCode !== 200) {
      toast.push({
        status: 'error',
        title: 'Failed to fetch URL metadata',
        description: error ? error.message : undefined
      });
      return;
    }

    var initial = {
      _type: type.name,
      crawledAt: new Date().toISOString(),
      url,
      resolvedUrl: newResolvedUrl
    }; // Reduce the returned fields to only schema-defined fields,
    // ensure that numbers are actual numbers (not strings)

    var doc = metaFieldNames.reduce((data, fieldName) => {
      var metaField = type.fields.find(item => item.name === fieldName);
      var metaValue = body[fieldName];

      if (!metaValue) {
        return data;
      }

      data[fieldName] = metaField.type.fields.reduce((obj, field) => {
        var fieldValue = metaValue[field.name];

        if (!fieldValue) {
          return obj;
        }

        if (field.type.jsonType === 'number') {
          fieldValue = Number(fieldValue);
        }

        obj[field.name] = fieldValue;
        return obj;
      }, {});
      return data;
    }, initial);
    onChange(_PatchEvent.default.from((0, _PatchEvent.set)(doc)));
    toast.push({
      status: 'success',
      title: 'Fetched URL metadata'
    });
  }, [toast, onChange, setIsLoading, setHasEdited]);
  var fetchMetadata = (0, _react.useCallback)(url => {
    setIsLoading(true);

    if (requestRef.current) {
      requestRef.current.unsubscribe();
    }

    var options = {
      url: '/addons/crown/resolve',
      query: {
        url
      },
      json: true
    };
    requestRef.current = sanityClient.observable.request(options).subscribe(res => handleReceiveMetadata(res, url), handleFetchError);
  }, [setIsLoading, requestRef, handleReceiveMetadata, handleFetchError]);
  var handleBlur = (0, _react.useCallback)(() => {
    if (!hasEdited || !value.url) {
      return;
    }

    fetchMetadata(value.url);
  }, [fetchMetadata, value, hasEdited]);
  var handleUrlKeyUp = (0, _react.useCallback)(evt => {
    if (evt.key === 'Enter') {
      fetchMetadata(evt.target.value);
    }
  }, [fetchMetadata]);
  var handleRefresh = (0, _react.useCallback)(() => {
    if (!value || !value.url) {
      return;
    }

    fetchMetadata(value.url);
  }, [fetchMetadata, value]);
  var handleFieldChange = (0, _react.useCallback)((field, patchEvent) => {
    onChange(patchEvent.prefixAll(field.name));
  }, [onChange]);
  var metaFields = (0, _react.useMemo)(() => {
    return type.fields.filter(field => metaFieldNames.includes(field.name));
  }, [type, metaFieldNames]);
  var legends = (0, _react.useMemo)(() => {
    return resolvedUrl && metaFieldNames.reduce((target, fieldName) => {
      var numItems = count(value[fieldName]);
      var base = metaFields.find(field => field.name === fieldName).type.title;
      var items = numItems > 1 ? 'items' : 'item';
      target[fieldName] = "".concat(base, " (").concat(numItems, " ").concat(items, ")");
      return target;
    }, {});
  }, [resolvedUrl, metaFields, metaFieldNames]); // only have presence markers for the "url" field appear on the root formfield

  var urlFieldPresence = presence.filter(item => item.path.length === 1 && item.path[0] === 'url');
  return /*#__PURE__*/_react.default.createElement(_ui.Stack, {
    space: 3
  }, /*#__PURE__*/_react.default.createElement(_components.FormField, {
    title: type.title,
    description: type.description,
    level: level,
    __unstable_markers: markers,
    __unstable_presence: urlFieldPresence,
    __unstable_changeIndicator: false,
    inputId: inputId
  }, /*#__PURE__*/_react.default.createElement(_changeIndicators.ChangeIndicatorForFieldPath, {
    path: ['url'],
    hasFocus: (focusPath === null || focusPath === void 0 ? void 0 : focusPath[0]) === 'url',
    isChanged: (value === null || value === void 0 ? void 0 : value.url) !== (compareValue === null || compareValue === void 0 ? void 0 : compareValue.url)
  }, /*#__PURE__*/_react.default.createElement(_ui.Flex, null, /*#__PURE__*/_react.default.createElement(_ui.Box, {
    flex: 1
  }, /*#__PURE__*/_react.default.createElement(_ui.TextInput, {
    id: inputId,
    ref: forwardedRef,
    type: "url",
    value: value === undefined ? '' : value.url,
    onKeyUp: handleUrlKeyUp,
    onChange: handleBeforeUrlChange,
    onFocus: handleFocus,
    onBlur: handleBlur,
    readOnly: readOnly
  })), /*#__PURE__*/_react.default.createElement(_ui.Box, {
    marginLeft: 1
  }, /*#__PURE__*/_react.default.createElement(_ui.Button, {
    mode: "ghost",
    type: "button",
    onClick: handleRefresh,
    disabled: readOnly || isLoading,
    text: isLoading ? 'Loading...' : 'Refresh'
  }))))), resolvedUrl && metaFields.map(field => /*#__PURE__*/_react.default.createElement(_components.FormFieldSet, {
    key: field.name,
    legend: legends[field.name],
    title: legends[field.name],
    level: level + 1,
    collapsible: true,
    collapsed: collapsed
  }, /*#__PURE__*/_react.default.createElement(_FormBuilderInput.FormBuilderInput, {
    value: value && value[field.name],
    compareValue: compareValue,
    type: field.type,
    onChange: patchEvent => handleFieldChange(field, patchEvent),
    path: [field.name],
    onFocus: onFocus,
    onBlur: onBlur,
    readOnly: readOnly || field.type.readOnly,
    focusPath: focusPath,
    markers: markers,
    presence: presence
  }))));
});

UrlMetadataInput.defaultProps = {
  value: undefined,
  compareValue: undefined,
  markers: [],
  presence: []
};
UrlMetadataInput.propTypes = {
  onChange: _propTypes.default.func.isRequired,
  level: _propTypes.default.number.isRequired,
  type: _propTypes.default.object,
  readOnly: _propTypes.default.bool,
  value: _propTypes.default.shape({
    url: _propTypes.default.string.isRequired,
    resolvedUrl: _propTypes.default.string,
    crawledAt: _propTypes.default.string,
    meta: _propTypes.default.shape({
      title: _propTypes.default.string,
      description: _propTypes.default.string
    }),
    openGraph: _propTypes.default.shape({
      title: _propTypes.default.string,
      description: _propTypes.default.string
    })
  }),
  compareValue: _propTypes.default.shape({
    url: _propTypes.default.string.isRequired,
    resolvedUrl: _propTypes.default.string,
    crawledAt: _propTypes.default.string,
    meta: _propTypes.default.shape({
      title: _propTypes.default.string,
      description: _propTypes.default.string
    }),
    openGraph: _propTypes.default.shape({
      title: _propTypes.default.string,
      description: _propTypes.default.string
    })
  }),
  onFocus: _propTypes.default.func.isRequired,
  onBlur: _propTypes.default.func.isRequired,
  focusPath: _propTypes.default.arrayOf(_propTypes.default.string),
  presence: _propTypes.default.arrayOf(_propTypes.default.object),
  markers: _propTypes.default.arrayOf(_propTypes.default.shape({
    type: _propTypes.default.string.isRequired
  }))
};
var _default = UrlMetadataInput;
exports.default = _default;